/*!

    \page howto.importazioni come fare a creare importazioni dati

    Guide pratiche passo passo alla creazione di meccanismi di importazione dati.

    introduzione
    ============
    In questo documento vedremo come realizzare vari tipi di sistemi di importazione dati per il framework. Il documento è piuttosto corposo quindi riassumiamo qui
    brevemente le varie tipologie di importazione e i passi necessari per realizzarle. Riguardo alla provenienza dei dati distinguiamo:

    - importazioni di file caricati tramite interfaccia web
    - importazioni di file caricati con altri sistemi (FTP, eccetera)
    - importazioni di dati da API REST
    - importazioni di dati da altri database

    Una menzione particolare meritano le operazioni effettuate tramite file standard (_src/_config/_740.controller.php) che non vanno considerate importazioni in
    quanto confluiscono nel normale funzionamento della controller.

    Riguardo alle modalità di importazione, possiamo distinguere:

    - le importazioni che girano in continuo, tramite task eseguito regolarmente
    - le importazioni che girano occasionalmente, con un task che attiva un job il quale poi esegue l'importazione

    Riguardo l'attivazione occasionale delle importazioni, questa può essere scatenata da un evento dell'interfaccia utente (il task è attivato dall'utente tramite
    l'interfaccia) oppure dal caricamento di un file (il task gira periodicamente, e se trova il file crea il job) oppure in maniera programmatica (il task gira
    periodicamente e crea il job ogni volta).

    come creare un'importazione custom da file
    ==========================================
    Creare un'importazione custom può essere necessario qualora gli utenti debbano caricare, come parte normale dell'utilizzo dell'applicazione, dati che hanno salvati
    in formati leggibili dal framework come Excel o CSV. Normalmente, le importazioni vengono gestite con un job (avviato da un task) data la loro natura di lavoro che
    ha un inizio e una fine chiaramente predeterminate, come meglio spiegato nella \ref crontab "pagina sui meccanismi di esecuzione pianificata del framework".

    Per realizzare un importatore da file sono necessari i seguenti passaggi:

    - creazione dell'interfaccia (tool) per il caricamento del file
    - creazione del task che avvia il job di importazione
    - creazione del job di importazione

    creazione del tool per il caricamento del file
    ----------------------------------------------
    Per agevolare il caricamento del file da parte degli utenti, la cosa migliore è predisporre un tool apposito nell'interfaccia. Questo tool andrà collocato nella pagina
    che anche intuitivamente è più facile associare alla natura dei dati importati (ad esempio un'importazione di dati anagrafici sarà cercata dagli utenti nei
    tools dell'anagrafica); in caso di forte ambiguità è possibile anche collocare lo stesso tool in più punti.

    Tipicamente, dovendo caricare un file, il metro tool più indicato per avviare l'importazione è il modal (vedi \ref templates_athena "la guida al template athena") che
    consente l'inserimento di un campo input di tipo file. Ricapitolando, andiamo a creare il metro button che avvia il task di creazione del job; se per esempio dobbiamo
    avviare un'importazione di dati amministrativi andremo a modificare _mod/_6000.amministrazione/_src/_inc/_macro/_amministrazione.tools.php (o la sua controparte custom
    se si tratta di un'importazione custom) aggiungendo un metro tool alla sezione importazioni:

    \code{.php}
    // importazione bonifici in formato WRI/CSV
    $ct['page']['contents']['metro']['importazioni'][] = array(
        'modal' => array( 'id' => 'importa_wri', 'include' => 'inc/amministrazione.tools.modal.import.wri.html' ),
        'icon' => NULL,
        'fa' => 'fa-upload',
        'title' => 'importazione file WRI bonifici',
        'text' => 'importa i bonifici ricevuti in formato WRI (un tipo di CSV)'
    );
    \endcode

    Questo richiederà la creazione di un modal, che andremo a piazzare nella sottocartella _mod/_6000.amministrazione/_src/_templates/_athena/inc (o la sua controparte
    custom) e che ci consentirà di caricare il file richiamando il task che farà il setup del job. Il codice del modal sarà simile a questo:

    \code{.html}
    <!-- Twig file included: {{ _self }} -->

    {% import '_bin/_form.html' as frm %}

    <script>
        function importa() {
          var data = $('#__upload_____wri__').val();
          getws('/task/6000.amministrazione/amministrazione.importazione.wri.start?file='+data);
          $('#importa_wri').modal('toggle');
          location.reload();
        }
    </script>

    <div class="modal" tabindex="-1" role="dialog" id="importa_wri">
        <div class="modal-dialog" role="document">
          <div class="modal-content">
              <div class="modal-header">
                <h5 class="modal-title">importa WRI/CSV bonifici</h5>
                <button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
              </div>
              <div class="modal-body">
                <div class="container-fluid">
                    <div class="form-row">
                      <div class="col">
                          {{ frm.uploader( '__upload__', '', '', '__wri__', '', '', '', 'var/contenuti/upload/', site ) }}
                      </div>
                    </div>
                    <div class="form-row">
                      <div class="col">
                        <p>scarica il <a href="/usr/examples/wri/wri.import.wri">modello WRI/CSV di esempio</a> per l'importazione</p>
                      </div>
                    </div>
                </div>
              </div>
              <div class="modal-footer">
                <button type="button" class="btn btn-secondary btn-sm" id="duplica-btn" onclick="importa();">importa</button>
                <button type="button" class="btn btn-secondary btn-sm" data-dismiss="modal">annulla</button>
              </div>
          </div>
        </div>
    </div>
    \endcode

    Sul codice qui sopra visto vanno fatte alcune considerazioni di carattere formale. Innanzitutto si noti che il modal contiene un link a un file di esempio,
    che si suggerisce sempre di inserire anche e soprattutto nel caso delle importazioni custom, che gli utenti possono utilizzare per controllare la correttezza
    sintattica e formale del file che stanno per caricare.

    creazione del task di avvio del job di importazione
    ---------------------------------------------------
    Si noti inoltre la funzione Javascript che richiama il task leggendo il percorso del file appena caricato, consentendo di fatto l'avvio del job; si noti anche
    che il task è richiamato con il percorso sintetico. Vediamo ora nel dettaglio il codice del task di avvio che andremo a creare in
    _mod/_6000.amministrazione/_src/_api/_task o nella sua controparte custom:

    \code{.php}
    <?php

        // inclusione del framework
      if( ! defined( 'CRON_RUNNING' ) ) {
          require '../../../../../_src/_config.php';
      }

        // inizializzo l'array del risultato
      $status = array();

        // nome file di default
        if( ! isset( $_REQUEST['file'] ) ) { 

            $status['err'][] = 'file da importare non specificato';

        } else {

            // creo il job
            $status['inserimento'] = mysqlQuery(
                $cf['mysql']['connection'],
                'INSERT INTO job ( nome, job, iterazioni, se_foreground, workspace ) VALUES ( ?, ?, ?, ?, ? )',
                array(
                    array( 's' => 'importazione tracciato WRI/CSV bonifici' ),
                    array( 's' => 'mod/6000.amministrazione/src/api/job/amministrazione.importazione.wri.php' ),
                    array( 's' => 1 ),
                    array( 's' => 1 ),
                    array( 's' => json_encode(
                        array(
                            'file' => 'var/contenuti/upload/'.basename( $_REQUEST['file'] )
                        )
                    ) )
                )
            );

        }

        // output
      if( ! defined( 'CRON_RUNNING' ) ) {
          buildJson( $status );
      }
    \endcode

    Il compito di questo task è piuttosto semplice, si limita a creare un job inserendo il nome del file da elaborare nel suo workspace. Si noti il meccanismo di
    protezione che impedisce la creazione del job nel caso in cui non sia specificato alcun file. Task più complessi possono prevedere una verifica formale del file,
    oppure una sua elaborazione preliminare (per esempio una conversione da XLS a CSV per comodità di lavoro, oppure trasformazioni o semplificazioni dei dati per
    facilitare il lavoro del job, eccetera).

    Il task di avvio che abbiamo appena visto è pensato per girare quando chiamato con un percorso di file come argomento; un altro caso frequente è che il task giri
    in continuo controllando se il file da elaborare appare in una determinata cartella (ad esempio perché è stato caricato via FTP). Per gestire questo tipo di
    scenario è necessario automatizzare l'esecuzione del task a intervalli regolari (si veda la documentazione sull'esecuzione automatica di operazioni pianificate
    per i dettagli) e il codice avrà una struttura simile a questa:

    \code{.php}
    <?php

        // inclusione del framework
        if( ! defined( 'CRON_RUNNING' ) ) {
            require '../../../../../_src/_config.php';
        }

        // inizializzo l'array del risultato
        $status = array();

        // cerco file CSV in tmp/upload/csv/anagrafica
        $status['files'] = glob( DIR_BASE . 'tmp/upload/csv/anagrafica/*.csv' );

        // se è presente almeno un file
        if( count( $status['files'] ) > 0 ) {

            // elaboro il primo file
            $status['file']['sorgente'] = array_shift( $status['files'] );

            // definisco la posizione di lavoro del file
            $status['file']['destinazione'] = str_replace( 'tmp/upload', 'tmp/elaborazione', $status['file']['sorgente'] );

            // sposto il file dall'area di upload
            $status['spostamento'] = moveFile( $status['file']['sorgente'], $status['file']['destinazione'] );

            // creo il job
            if( $status['spostamento'] !== false ) {

                // creo il job
                $status['inserimento'] = mysqlQuery(
                    $cf['mysql']['connection'],
                    'INSERT INTO job ( nome, job, iterazioni, se_foreground, workspace ) VALUES ( ?, ?, ?, ?, ? )',
                    array(
                        array( 's' => 'importazione tracciato WRI/CSV bonifici' ),
                        array( 's' => 'mod/6000.amministrazione/src/api/job/amministrazione.importazione.wri.php' ),
                        array( 's' => 1 ),
                        array( 's' => 1 ),
                        array( 's' => json_encode(
                            array(
                                'file' => $status['file']['destinazione']
                            )
                        ) )
                    )
                );

                // status
                $status['info'][] = 'file ' . $status['file']['sorgente'] . ' spostato in ' . $status['file']['destinazione'];

            } else {

                // status
                $status['err'][] = 'errore nello spostamento del file da importare';

            }

        } else {

                // status
                $status['info'][] = 'nessun file da importare';

        }

        // output
        if( ! defined( 'CRON_RUNNING' ) ) {
            buildJson( $status );
        }
    \endcode

    Tipicamente, quando si crea un job di importazione che lavora su un file, può essere opportuno eliminare quel file alla fine del job. Più avanti vedremo come creare il file del job
    e come gestire, fra le altre, anche questa evenienza.

    creazione del job di importazione
    ---------------------------------
    Per quanto riguarda il codice del job, rimandiamo alla \ref crontab_job "sezione relativa ai job della documentazione", ci limitiamo qui a dare alcune indicazioni
    di massima e a riportare il codice di esempio. Si tenga presente innanzitutto la necessità di fare debug del job, specialmente se si tratta di un job custom;
    questo è facilitato dalla possibilità di eseguire il job stesso in modalità passo passo richiamando l'API job e nella stesura del codice converrà inserire
    quante più informazioni possibili nello status del job.

    \code{.php}
    <?php

        /* INIZIO CODICE JOB */

        /* 01. VERIFICHE FORMALI */
        if( ! defined( 'CRON_RUNNING' ) && ! defined( 'JOB_RUNNING' ) ) {

            // status
            $job['workspace']['status']['error'][] = 'questo job non supporta la modalità standalone';

            // output
            buildJson( $job['workspace']['status'] );

        } elseif( empty( $job['id'] ) ) {

            // status
            $job['workspace']['status']['error'][] = 'ID job non trovato';

        } elseif( isset( $job['corrente'] ) && $job['corrente'] > $job['totale'] ) {

            // status
            $job['workspace']['status']['info'][] = 'iterazione a vuoto su job completato';

        } elseif( ! isset( $job['workspace']['file'] ) || empty( $job['workspace']['file'] ) ) {

            // status
            $job['workspace']['status']['error'][] = 'questo job richiede un file su cui lavorare';

        } elseif( ! file_exists( fullPath( $job['workspace']['file'] ) ) ) {

            // status
            $job['workspace']['status']['error'][] = 'impossibile trovare il file ' . $job['workspace']['file'];

        } elseif( ! is_readable( fullPath( $job['workspace']['file'] ) ) ) {

            // status
            $job['workspace']['status']['error'][] = 'impossibile leggere il file ' . $job['workspace']['file'];

        } else {

            /* 02. ATTIVITÀ DI AVVIO */
            if( empty( $job['corrente'] ) ) {

                // inizializzo l'array
                $arr = csvFile2array( $job['workspace']['file'], ';' );

                // segno il totale delle cose da fare
                $job['totale'] = count( $arr );

                // avvio il contatore
                $job['corrente'] = 1;

                // timestamp di avvio
                if( empty( $job['timestamp_apertura'] ) ) {
                    mysqlQuery(
                        $cf['mysql']['connection'],
                        'UPDATE job SET totale = ?, timestamp_apertura = ? WHERE id = ?',
                        array(
                            array( 's' => $job['totale'] ),
                            array( 's' => time() ),
                            array( 's' => $job['id'] )
                        )
                    );
                }

                // status
                $job['workspace']['status']['info'][] = 'file: ' . $job['workspace']['file'];
                $job['workspace']['status']['info'][] = 'requisiti formali soddisfatti, inizializzo il job';
                $job['workspace']['status']['info'][] = 'righe trovate: ' . $job['totale'];
                $job['workspace']['status']['info'][] = 'colonne trovate: ' . implode( ', ', array_keys( $arr[0] ) );

            } else {

                // leggo la lista
                $arr = csvFile2array( $job['workspace']['file'], ';' );

                // incremento l'indice di lavoro
                $job['corrente']++;

            }

            /* 03. AVANZAMENTO DEL JOB */
            if( empty( $job['totale'] ) || $job['corrente'] > $job['totale'] ) {

                /* 03.1. OPERAZIONI DI CHIUSURA */

                // scrivo la timestamp di completamento
                $jobs = mysqlQuery(
                    $cf['mysql']['connection'],
                    'UPDATE job SET timestamp_completamento = ? WHERE id = ?',
                    array(
                        array( 's' => time() ),
                        array( 's' => $job['id'] )
                    )
                );

            } else {

                /* 03.2. CODICE PRINCIPALE DEL JOB */

                // aggiusto l'indice di lavoro (gli array partono da zero)
                $widx = $job['corrente'] - 1;

                // prelevo la riga da lavorare
                $row = $arr[ $widx ];

                // controlli formali sulla riga
                // TODO aggiungere tutti i controlli formali necessari aggiungendo elseif() secondo la bisogna
                if( empty( $row ) ) {

                    // status
                    $job['workspace']['status']['righe'][ $job['corrente'] ]['error'][] = 'riga vuota ' . $job['corrente'];

                } else {

                    // status
                    $job['workspace']['status']['righe'][ $job['corrente'] ]['info'][] = 'inizio a lavorare la riga ' . $job['corrente'];

                    // TODO qui inserire le logiche di importazione della singola riga

                }

                /* 03.3. AGGIORNAMENTO STATO DEL JOB */
                $jobs = mysqlQuery(
                    $cf['mysql']['connection'],
                    'UPDATE job SET corrente = ? WHERE id = ?',
                    array(
                        array( 's' => $job['corrente'] ),
                        array( 's' => $job['id'] )
                    )
                );

            }

        }

        /* FINE CODICE JOB */
    \endcode

    importazione di file e immagini
    -------------------------------
    Una nota a parte merita l'importazione di file e immagini rispetto alla semplice lettura e scrittura di dati dal database [...].

    \code{.php}

    

    \endcode

    come creare un'importazione custom da database
    ==============================================
    Questa strategia è da applicare in tutti i casi nei quali i dati da importare si trovano su un altro database; lo scenario cambia leggermente a seconda se è possibile modificare o meno
    la struttura delle tabelle dalle quali si deve leggere. A prescindere dallo scenario, i passi da eseguire sono sempre gli stessi:

    - normalizzazione dello scenario di provenienza dei dati
    - creazione del task di importazione

    Si suggerisce di utilizzare un task per questo tipo di importazione in quanto non è sempre possibile avere il controllo sui dati da importare, e questi potrebbero cambiare nel corso dell'importazione.

    normalizzazione dello scenario di provenienza dei dati
    ------------------------------------------------------
    Nel caso in cui sia possibile modificare la struttura della tabella dalla quale si devono leggere i dati, sarà opportuno aggiungere le colonne token e timestamp_sincronizzazione; con questa coppia
    di colonne si potrà applicare alla lettura della tabella il meccanismo di lock per riga con token che già conosciamo.

    Se non è possibile modificare la struttura della tabella di provenienza dei dati, ma ci sono colonne inutilizzate che possono essere sfruttate per emulare il comportamento delle colonne token e
    timestamp_sincronizzazione, allora si ricadrà nel caso precedente, avendo semplicemente cura di sostituire i nomi delle colonne con quelli effettivamente usati.

    Se infine non è possibile agire sulla struttura della tabella sorgente e non vi sono colonne che possono essere usate per il lock, allora si consiglia caldamente di creare un passaggio intermedio
    in cui i dati della tabella di provenienza vengono copiati su una tabella d'appoggio che possa essere modificata.

    Una volta trovato il modo di creare uno scenario al quale possa essere applicata la strategia del lock per riga, si procederà alla creazione del task di importazione.

    creazione del task di importazione
    ----------------------------------
    La struttura del task di importazione è organizzata in maniera molto semplice su due blocchi funzionali distinti uniti da una query di collegamento. Il task va salvato nella cartella _src/_api/_task/ o
    nella corrispondente cartella del modulo cui appartiene l'importazione, oppure nelle loro controparti custom se l'importazione non fa parte dello standard. Vediamo la struttura del task:

    \code{.php}
    <?php

        /* INIZIO CODICE TASK */

        // inclusione del framework
        if( ! defined( 'CRON_RUNNING' ) ) {
            require '../../../_src/_config.php';
        }

        /* 01. SETUP */

        // inizializzo l'array del risultato
        $status = array();

        // inizializzo l'array degli headers
        $headers = array();

        // status
        $status['info'][] = 'inizio operazioni task ' . basename( __FILE__ );

        // chiave di lock
        $status['token'] = getToken( __FILE__ );

        // connessione al vecchio database
        $cOld	= mysqli_connect( 'hostDb', 'userDb', 'passwordDb', 'nomeDatabase' );

        // alias per la connessione al nuovo database
        $cNew	= $cf['mysql']['connection'];

        /* 02. VERIFICHE FORMALI */
        if( empty( $cOld ) ) {

            // status
            $status['err'][] = 'impossibile connettersi al vecchio database';

        } elseif( empty( $cNew ) ) {

            // status
            $status['err'][] = 'impossibile connettersi al nuovo database';

        } else {

            // charset
            mysqli_set_charset( $cOld, 'utf8' );
            mysqli_query( $cOld, 'SET collation_connection = utf8_unicode_ci' );

            /* 03. LOCK DELLA RIGA DA IMPORTARE */
            if( isset( $_REQUEST['id'] ) ) {

                // recupero dati in modalità riga specifica
                mysqlQuery( $cOld,
                    'UPDATE oldTable SET token = ? WHERE id = ? AND token IS NULL',
                    array(
                        array( 's' => $status['token'] ),
                        array( 's' => $_REQUEST['id'] )
                    )
                );

                // output
                $status['info'][] = 'elemento da importare specificato in maniera esplicita';

            } elseif( isset( $_REQUEST['f'] ) ) {

                // recupero dati in modalità forzata
                mysqlQuery( $cOld,
                    'UPDATE oldTable SET token = ? WHERE token IS NULL '.
                    'ORDER BY timestamp_sincronizzazione ASC, id ASC LIMIT 1',
                    array(
                        array( 's' => $status['token'] )
                    )
                );

                // output
                $status['info'][] = 'importazione forzata di un elemento';

            } else {

                // recupero dati
                mysqlSelectRow( $cOld,
                    'UPDATE oldTable SET token = ? '.
                    'WHERE ( timestamp_sincronizzazione < timestamp_aggiornamento '.
                    'OR timestamp_sincronizzazione IS NULL ) AND token IS NULL '.
                    'ORDER BY timestamp_sincronizzazione ASC, id ASC LIMIT 1',
                    array(
                        array( 's' => $status['token'] )
                    )
                );

                // output
                $status['info'][] = 'ricerca standard di un elemento da importare';

            }

            /* 04. SELEZIONE DELLA RIGA DA IMPORTARE */
            $r = mysqlSelectRow( $cold,
                'SELECT * FROM oldTable WHERE token = ? ',
                array(
                    array( 's' => $status['token'] )
                )
            );
        
            /* 05. LAVORAZIONE DELLA RIGA DA IMPORTARE */
            if( ! empty( $r ) ) {

                // status
                $status['info'][] = 'importo la riga #' . $r['id'];

                /* 05.1 OPERAZIONI DI IMPORTAZIONE */

                /* 05.2 SBLOCCO DELLA RIGA */
                mysqlQuery( $cold,
                    'UPDATE oldTable SET token = NULL, timestamp_sincronizzazione = ? WHERE token = ?',
                    array(
                        array( 's' => time() ),
                        array( 's' => $status['token'] )
                    )
                );

            } else {

                // status
                $status['err'][] = 'nessuna riga da importare';

            }

        }

        /* 06. OUTPUT */
        if( ! defined( 'CRON_RUNNING' ) ) {

            // se è impostata la modalità automatica
            if( isset( $_REQUEST['a'] ) && ! empty( $r['id'] ) ) {
                $headers[] = 'refresh:'.$_REQUEST['a'].';url='.$_SERVER['REQUEST_URI'];
            }

            // output
            buildHTML( '<pre>' . print_r( $status, true ) . '</pre>', NULL, ENCODING_UTF8, $headers );

        }

        /* FINE CODICE TASK */
    \endcode

    Riguardo alle strategie di individuazione della riga su cui lavorare, si tengano presenti alcuni fattori. Innanzitutto, è importante sottolineare
    che potrebbero esserci delle condizioni aggiuntive da considerare per le clausele WHERE (ad esempio, importando delle notizie potrei non voler importare
    quelle troppo vecchie, eccetera); quindi bisogna riflettere attentamente su questo prima di comporre le query definitive.

*/
